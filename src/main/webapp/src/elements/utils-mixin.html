<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/paper-toast/paper-toast.html">
<link rel="import" href="confirm-dialog.html">
<script src="../../bower_components/moment/moment.js"></script>

  <script>
    /**
     * Adds a bunch of utility date manipulation methods.
     */
    window.LocaleUtilsMixin = subclass => class extends subclass {
      _getDay(date) {
        return moment(new Date(date)).format('MMM D');
      }

      _getHeaderDay(date) {
        return moment(new Date(date)).format('ddd, MMM D');
      }

      _getWeekRangeBefore() {
        var dayBeforeYesterday = moment().subtract(2, 'day').startOf('day');
        return this._getHeaderDay(moment().startOf('isoWeek')) + ' - ' +
               this._getHeaderDay(dayBeforeYesterday);
      }

      _getWeekRangeAfter(date) {
        var tomorrow = moment().add(1, 'day').startOf('day');
        return this._getHeaderDay(tomorrow) + ' - ' +
               this._getHeaderDay(moment().endOf('isoWeek'));
      }

      _getWeekday(date) {
        return moment(new Date(date)).format('dddd');
      }

      _getFullDate(date) {
        return moment(new Date(date)).format('DD/MM/YYYY HH:mm');
      }

      _setHour(str, date) {
        const hour = parseInt(str.split(/:/)[0]);
        date.setHours(hour, 0, 0);
      }

      _getDayIso(str) {
        if (str) {
          return moment(new Date(Date.parse(str))).format('YYYY-MM-DD');
        }
      }

      _isYesterday(date) {
        return moment().subtract(1, 'days').startOf('day').isSame(new Date(date), 'day');
      }

      _isToday(date) {
        return moment().isSame(new Date(date), 'day');
      }

      _isThisWeekBeforeYesterday(date) {
        // Is this week until the day before yesterday (excluded)
        return (moment(new Date(date)).isAfter(moment().startOf('week')) &&
                moment(new Date(date)).isBefore(moment().subtract(1, 'days').startOf('day')));
      }

      _isThisWeekStartingTomorrow(date) {
        // Is this week starting tomorrow
        return (moment().isBefore(moment(new Date(date)), 'day') &&
                moment(new Date(date)).isBefore(moment().endOf('week').add(1, 'day')));
      }

      _isRecent(date) {
        return moment(new Date(date)).isBefore(moment().startOf('week').add(1, 'day'));
      }

      _isUpcoming(date) {
        return moment(new Date(date)).isAfter(moment().endOf('week').add(1, 'day'));
      }

      _getTime(time) {
        return moment(time, 'HH:mm').format('hh:mm a');
      }

      _getShortDay(date) {
        return moment(new Date(date)).format('ddd D');
      }

      _getFullDay(date) {
        return moment(new Date(date)).format('dddd');
      }

      _getMonth(date) {
        return moment(new Date(date)).format('MMM D');
      }

      _getCurrency(price) {
        price = price || 0;
        return (price / 100).toLocaleString('en-US', {style: 'currency', currency: 'USD'});
      }

      _getPrice(price) {
        price = price || 0;
        return (price / 100).toLocaleString('en-US', {style: 'decimal', minimumFractionDigits: 2});
      }
    };

    /**
     * Adds the scroll-shadow attribute if there is a `#main` element with scrollsize
     * larger than its height, and there is hidden content at the bottom.
     */
    /* @polymerMixin */
    window.ScrollShadowMixin = subclass => class extends subclass {
      static get properties() {
        return {
          scrollShadow: {
            type: Boolean,
            reflectToAttribute: true
          },
          _main: Element
        };
      }

      ready() {
        super.ready();
        Polymer.RenderStatus.afterNextRender(this, () => {
          this._main = this.root.querySelector('#main');
          if (this._main) {
            this._main.addEventListener('scroll', this._contentScroll.bind(this));
            this._contentScroll();
          }
        });
      }

      _contentScroll() {
        this.scrollShadow = this._main.scrollHeight - this._main.scrollTop !== this._main.clientHeight;
      }
    };

    /**
     * Mixin for grids.
     */
    window.EditableListMixin = subclass => class extends subclass {
      static get properties() {
        return {
          _activeItem: {
            observer: '_onActiveItem'
          },
          _editableItem: Object
        };
      }

      get dirty() {
        return this.$.editor.dirty;
      }

      _onActiveItem() {
        this._editItem();
      }

      _newItem() {
        this._editableItem = {};
      }

      _editItem() {
        // activeItem is set after clicking on grid elements
        setTimeout(() => {
          this._editableItem = this._activeItem;
        });
      }

      _onClose() {
        this.$.grid.selectedItems = [];
        this.$.grid.activeItem = null;
        this._editableItem = null;
      }

      _onBeforeClose(e) {
        if (this.dirty) {
          e.preventDefault();
        }
      }

      _onSave(e) {
        window.console.log('SAVE', e.detail);
      }

      _onDelete(e) {
        window.console.log('DELETE', e.detail);
      }

      _filterItems(change, filter) {
        const items = change.base;
        if (items && filter) {
          return items.filter((item) => {
            return item.keys().reduce((last, current) => {
              return last || item.current.toString.toLowerCase().includes(filter);
            }, false);
          });
        }
        return items;
      }
    };

    /**
     * Mixin for editors.
     */
    /* @polymerMixin */
    window.EditableItemMixin = subclass => class extends subclass {
      static get properties() {
        return {
          item: Object,

          _editableItem: Object,

          dirty: {
            type: Boolean,
            value: false
          },

          _dialog: Element,
          deleteCaption: {
            value: 'Confirm Delete Item'
          },
          deleteMessage: {
            value: 'Are you sure you want to delete the selected Item?. This action cannot be undone.'
          },
          deleteOkText: {
            value: 'Delete'
          },
          deleteCancelText: {
            value: 'Cancel'
          },
          unsavedCaption: {
            value: 'Unsaved Changes'
          },
          unsavedMessage: {
            value: 'There are unsave modifications to the Item. Are you sure to cancel the edition.'
          },
          unsavedOkText: {
            value: 'Yes'
          },
          unsavedCancelText: {
            value: 'Back'
          }
        };
      }

      static get observers() {
        return [
          '_onItemChanged(item)',
          '_checkDirty(_editableItem.*)'
        ];
      }

      ready() {
        super.ready();
        Polymer.RenderStatus.afterNextRender(this, () => {
          this._dialog = document.createElement('confirm-dialog');
          document.body.appendChild(this._dialog);
        });
      }

      _onItemChanged() {
        this.dirty = false;
        this._originalItemString = JSON.stringify(this.item);
        this._editableItem = Object.assign({}, this.item);
      }

      _checkDirty() {
        this.dirty = JSON.stringify(this._editableItem) != this._originalItemString;
      }

      cancel() {
        if (this.dirty) {
          this._confirm(() => this.close(true),
            this.unsavedCaption, this.unsavedMessage, this.unsavedOkText, this.unsavedCancelText);
        } else {
          this.close();
        }
      }

      close(force) {
        // if forced set dirty to true to avoid preventing close on before-close phase
        this.dirty = !force && this.dirty;
        this.dispatchEvent(new CustomEvent('close', {bubbles: true, composed: true}));
      }

      save() {
        this.item = Object.assign(this.item, this._editableItem);
        this.dispatchEvent(new CustomEvent('save', {bubbles: false, composed: true, detail: this.item}));
        this.close(true);
      }

      delete() {
        this._confirm(() => {
          this.dispatchEvent(new CustomEvent('delete', {bubbles: true, composed: true, detail: this.item}));
          this.close(true);
        }, this.deleteCaption, this.deleteMessage, this.deleteOkText, this.deleteCancelText);
      }

      _confirm(callback, caption, message, okText, cancelText) {
        this._dialog.callback = callback;
        this._dialog.caption = caption;
        this._dialog.message = message;
        this._dialog.okText = okText;
        this._dialog.cancelText = cancelText;
        this._dialog.opened = true;
      }
    };

    /**
     * Mixin for editors.
     */
    /* @polymerMixin */
    window.NotificationMixin = subclass => class extends subclass {

      static get properties() {
        return {
          _defaultToast: Object,
          _persistentToast: Object
        };
      }

      ready() {
        super.ready();
        Polymer.RenderStatus.afterNextRender(this, () => {
          this._defaultToast = document.getElementById('_defaultToast');
          if (!this._defaultToast) {
            this._defaultToast = document.createElement('paper-toast');
            this._defaultToast.setAttribute('id', '_defaultToast');
            document.body.appendChild(this._defaultToast);
          }

          this._persistentToast = document.getElementById('_persistentToast');
          if (!this._persistentToast) {
            this._persistentToast = document.createElement('paper-toast');
            this._persistentToast.setAttribute('id', '_persistentToast');
            this._persistentToast.setAttribute('duration', '0');
            this._persistentToast.innerHTML =
              '<paper-button onclick="this.parentElement.toggle()" class="yellow-button">Close</paper-button>';
            document.body.appendChild(this._persistentToast);
          }
        });
      }

      displayToast(message, persistent) {
        Polymer.RenderStatus.afterNextRender(this, () => {
          const toast = persistent ? this._persistentToast : this._defaultToast;
          toast.style['z-index'] = 1000;
          toast.setAttribute('text', message);
          toast.open();
        });
      }
    };
  </script>
</dom-module>
